[{"title":"js中this指向问题","url":"/2021/03/14/js中this指向问题/","content":"\n 引与[这里](https://www.cnblogs.com/chengxs/p/8679313.html)\n\n**一、普通函数调用**\n\n**二、对象函数调用**\n\n**三、构造函数调用**\n\n**四、apply和call调用**\n\n**五、箭头函数调用**\n\n## **一、普通函数调用**\n\n这个情况没特殊意外，就是指向全局对象-window。\n\n**1、使用let**\n\n```js\n/*普通函数调用*/\nlet username = \"程新松\";\nfunction fn(){\n    console.log(this.username);   //undefined\n}\nfn();\n```\n\n![image-20210314212805398](js中this指向问题/image-20210314212805398.png)\n\n**2、使用var**\n\n```js\nvar name = \"程新松\";\nfunction fn(){\n    console.log(this.name);\n}\nfn();\n```\n\n使用node输出的是：undefined\n\n使用谷歌浏览器console输出的是：程新松\n\n**3、使用window**\n\n```js\nwindow.username='程新松'\nfunction fn(){\n    console.log(this.username);\n}\nfn();\n```\n\n![image-20210314212951656](js中this指向问题/image-20210314212951656.png)\n\n**4、let和var区别：**\n\n**`（1）let` 允许把变量的作用域限制在块级域中；var** **申明变量要么是全局的，要么是函数级的，而无法是块级的。**\n\n```js\nlet varClass = function(){\n    var name='程新松';\n    if(true){\n        var name='saucxs';\n        console.log(name);\n    }\n    console.log(name);\n}\nvarClass();\n// saucxs\n// saucxs\n```\n\n![image-20210314213048526](js中this指向问题/image-20210314213048526.png)\n\n```js\nlet letClass = function(){\n    let name='程新松';\n    if(true){\n        let name='saucxs';\n        console.log(name);\n    }\n    console.log(name);\n}\nletClass();\n```\n\n![image-20210314213115462](js中this指向问题/image-20210314213115462.png)\n\n**上面的结果说明了let只在｛｝内使用。**\n\n**（2）先let后var**\n\n```js\nlet subClass = function(){\n    let name='程新松';\n    if(true){\n        var name='saucxs';\n        console.log(name);\n    }\n    console.log(name);\n}\nsubClass();\n```\n\n![image-20210314213152599](js中this指向问题/image-20210314213152599.png)\n\nvar 是函数级作用域，相当于一个作用域中有两个n的变量了\n\nvar 作用于整个 subClass ，和let冲突了，let不能重复声明，already been declared=已经被声明\n\n**（3）先var后let**\n\n```js\nlet subClass = function(){\n    var name='程新松';\n    if(true){\n        let name='saucxs';\n        console.log(name);\n    }\n    console.log(name);\n}\nsubClass();\n```\n\n![image-20210314213240143](js中this指向问题/image-20210314213240143.png)\n\n先申明var，再申明let，这个没有问题。\n\n**二、对象函数调用**\n\n 这个相信不难理解，就是**哪个函数调用，this指向哪里**。\n\n```js\n/*对象函数调用*/\n//window.name='程新松';\n//var name='程新松';\nlet name='程新松';\nlet obj={\n    id:201102304,\n    fn:function(){\n        console.log(this.name);  //undefined\n        console.log(this.id);   //201102304\n    }\n}\nobj.fn();\n```\n\n![image-20210314213318807](js中this指向问题/image-20210314213318807.png)\n\n很明显，第一次就是输出 `obj.name` ，但是没有这个name属性，输出的结果undefined。而第二次输出`obj.id，有这个id属性，`输出 201102304，**因为 `this` 指向 `obj` 。**\n\n **有一种情况需要注意：**\n\n```js\n/*需要注意的情况*/\nlet obj1={\n    a:111\n}\nlet obj2={\n    a:222,\n    fn:function(){\n        console.log(this.a);\n    }\n}\nobj1.fn=obj2.fn;\nobj1.fn();  //111\n```\n\n![image-20210314213352343](js中this指向问题/image-20210314213352343.png)\n\n这个也不难理解，虽然 `obj1.fn` 是从 `obj2.fn` 赋值而来，但是调用函数的是 `obj1` ，所以 **`this` 指向 `obj1`** 。\n\n**三、构造函数调用**\n\n```js\n/*构造函数调用*/\nlet structureClass=function(){\n    this.name='程新松';\n}\nlet subClass1=new structureClass();\nconsole.log(subClass1.name);\n\nlet subClass=new structureClass();\nsubClass.name='成才';\nconsole.log(subClass.name);\n```\n\n![image-20210314213431971](js中this指向问题/image-20210314213431971.png)\n\n但是有一个坑，虽然一般不会出现，但是有必要提一下。\n\n**在构造函数里面返回一个对象，会直接返回这个对象，而不是执行构造函数后创建的对象**\n\n```js\nlet structureClass=function(){\n    this.name='程新松';\n    return {\n        username:'saucxs'\n    }\n}\nlet subClass1=new structureClass();\nconsole.log(subClass1);\nconsole.log(subClass1.name);\n```\n\n![image-20210314213502240](js中this指向问题/image-20210314213502240.png)\n\n**四、apply和call调用**\n\n **1、apply和call简单来说就是会改变传入函数的this。**\n\n```js\n/*apply和call调用*/\nlet obj1={\n    name:'程新松'\n};\nlet obj2={\n    name:'saucxs',\n    fn:function(){\n        console.log(this.name);\n    }\n}\nobj2.fn.call(obj1);\n```\n\n![image-20210314213534128](js中this指向问题/image-20210314213534128.png)\n\n**此时虽然是 `obj2` 调用方法，但是使用 了 `call` ，动态的把 `this` 指向到 `obj1` 。相当于这个 `obj2.fn` 这个执行环境是 `obj1` 。**\n\n**`call` 和 `apply` 两个主要用途：**\n\n1.改变 `this` 的指向（把 `this` 从 `obj2` 指向到 `obj1` ）\n\n2.方法借用（ `obj1` 没有 `fn` ，只是借用 `obj2` 方法）\n\n**2、call与apply区别**\n\n `call` 和 `apply` 的作用，完全一样，唯一的区别就是在参数上面。\n\n**`call` 接收的参数不固定，第一个参数是函数体内 `this` 的指向，第二个参数以下是依次传入的参数。**\n\n**apply接收两个参数，第一个参数也是函数体内 `this` 的指向。第二个参数是一个集合对象（数组或者类数组）**\n\n```js\n/*apply和call区别*/\nlet fn=function(a,b,c){\n    console.log(a,b,c);\n}\nlet arrArray=[1,2,3];\nfn.call(window,arrArray);\nfn.apply(window,arrArray);\n```\n\n![image-20210314213614310](js中this指向问题/image-20210314213614310.png)\n\n **五、箭头函数调用**\n\n 首先不得不说，ES6 提供了箭头函数，增加了我们的开发效率，**但是在箭头函数里面，没有 `this`** ，**箭头函数里面的 `this` 是继承外面的环境**。\n\n```js\n/*箭头函数调用*/\nlet obj={\n    name:'程新松',\n    fn:function(){\n        setTimeout(function(){console.log(this.name)})\n    }\n}\nobj.fn();\n```\n\n![image-20210314213641400](js中this指向问题/image-20210314213641400.png)\n\n不难发现，虽然 **fn()** 里面的 **this** 是指向 **obj** ，但是，传给 **setTimeout** 的是普通函数， **this** 指向是 **window** ， **window** 下面没有 **name** ，所以这里输出 **underfind** 。\n\n **换成箭头函数**\n\n```js\n//换成箭头函数\nlet obj={\n    name:\"程新松\",\n    fn:function(){\n        setTimeout(()=>{console.log(this.name)});\n    }\n}\nobj.fn();\n```\n\n![image-20210314213710596](js中this指向问题/image-20210314213710596.png)\n\n这次输出 **程新松** 是因为，传给 **setTimeout** 的是箭头函数，然后箭头函数里面没有 **this** ，所以要向上层作用域查找，在这个例子上， **setTimeout** 的上层作用域是 **fn** 。而 **fn** 里面的 **this** 指向 **obj** ，所以 **setTimeout** 里面的箭头函数的 **this** ，指向 **obj** 。所以输出 **程新松**。","tags":["前端基础题"]},{"title":"对闭包的理解","url":"/2021/03/14/对闭包理解/","content":"\n1、什么是闭包？ 闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。\n\n2、闭包的作用：延伸变量的作用范围。\n\n```js\n function fn() { // fn就是闭包函数\n   var num = 10;\n   function fun() {\n       console.log(num);\n \t}\n    return fun;\n }\nvar f = fn();\nf();\n\n```\n\n引与[这里](https://www.cnblogs.com/zranguai/p/13605228.html)","tags":["前端基础题"]},{"title":"GET和POST两种基本请求方法的区别","url":"/2021/03/14/GET和POST两种基本请求方法的区别/","content":"\n1. GET在浏览器回退时是无害的，而POST会再次提交请求。\n2. GET产生的URL地址可以被[Bookmark](https://zhidao.baidu.com/question/310542327522637404.html)，而POST不可以。\n3. GET请求会被浏览器主动[cache](https://www.yikaow.com/yikao/53414.html)，而POST不会，除非手动设置。\n4. GET请求只能进行url编码，而POST支持多种编码方式。\n5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\n6. [GET请求在URL中传送的参数是有长度限制的](https://www.cnblogs.com/cuihongyu3503319/p/5892257.html)，而POST没有。\n7. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\n8. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\n9. GET参数通过URL传递，POST放在Request body中。\n\n具体可参见[这里](https://www.cnblogs.com/logsharing/p/8448446.html)","tags":["前端基础题"]},{"title":"每日总结6","url":"/2021/03/14/每日总结6/","content":"## 今天做了什么？\n\n1、回了趟老家，理了个发，看了部动漫，看了几道前端题，回来还把车刮了，搞心态了。\n\n## 今天有什么收获和问题？\n\n1、身体健康很重要！\n\n2、心理健康也很重要！\n\n3、自己的心态调节能力还是可以的。\n\n4、压力是真实存在的，可以从心理层面影响生活，意识到若是自己能无视掉压力并且按照计划走能够达成预期目标。\n\n5、很早之前就察觉到一种现象：在晚上躺在床上的时候悲观情绪容易蔓延，同一件事情，在白天的时候思考会觉得虽然压力有困难，但是相信自己完全能够克服，没有明显的悲观情绪，但是到了晚上则会产生悲观情绪。解决方法就是晚上不去考虑那些可能会让自己产生悲观情绪的事情，因为你哪一次一旦放纵这种悲观情绪蔓延，可能就会一发不可收拾，造成不可逆的后果，这一点自己隐隐能够察觉到。所以总体上我是一个向往乐观，并在一天中大部分时间想要保持心态乐观的人。\n\n## 之后的计划？\n\n1、饮食计划和身体调养计划不是现在做的，但也要注意个人健康方面的问题。\n\n2、关于前端方面，目前基本的前端知识都学了一遍，对前端方面做一个阶段性计划。\n\n最终目标：独立分别以Bootstrap，Vue框架做个项目。\n\n具体操作：①先把所学的内容粗略过一遍，预计需要2~3，因为有些知识忘了或当时学的时候就没完全   \t\t\t\t\t掌握，如Ajax。\n\n​\t\t\t\t\t②每天都要做几道前端题，查漏补缺。\n\n​\t\t\t\t\t③复习的差不多的时候就找几个项目做，当然做项目之前也要充分的做好事前准备。\n\n3、毕业设计，近期尽快将课题定下来，新增功能搞完。预计2~3天。","tags":["生活"]},{"title":"每日总结5","url":"/2021/03/13/每日总结5/","content":"\n### 今天都做了什么？\n\n1、结束了小程序的学习。\n\n2、完成了开题答辩。\n\n3、看了几道前端题。\n\n### 有什么收获和问题？\n\n1、没有，先学着。\n\n### 明日计划？\n\n1、回老家。\n\n2、回来重整一下思路。","tags":["生活"]},{"title":"清除浮动的几种方法","url":"/2021/03/13/清除浮动的几种方法/","content":"\n### 1、额外标签法\n\n![image-20210313222508031](清除浮动的几种方法/image-20210313222508031.png)\n\n### 2、父级添加overflow\n\n![image-20210313222603473](清除浮动的几种方法/image-20210313222603473.png)\n\n![image-20210313222624893](清除浮动的几种方法/image-20210313222624893.png)\n\n### 3、：after 伪元素法\n\n![image-20210313222702298](清除浮动的几种方法/image-20210313222702298.png)\n\n![image-20210313222714894](清除浮动的几种方法/image-20210313222714894.png)\n\n### 4、双伪元素清除浮动\n\n![image-20210313222736786](清除浮动的几种方法/image-20210313222736786.png)\n\n![image-20210313222749355](清除浮动的几种方法/image-20210313222749355.png)\n\n","tags":["前端基础题"]},{"title":"常见的浏览器兼容性问题1","url":"/2021/03/13/常见的浏览器兼容性问题1/","content":"\n### 1、不同浏览器的标签默认的margin和padding不同\n\n问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。\n\n解决方案：可以使用Normalize.css来清除默认样式,或使用如下代码。\n\n```css\nbody,h1,h2,h3,ul,li,input,div,span,a,form …… { margin:0; padding:0; }\n```\n\n### 2、cursor:hand 显示手型在safari 上不支持\n\n解决方案：统一使用 cursor:pointer。\n\n### 3、两个块级元素，父元素设置了overflow:auto；子元素设置了position:relative ;且高度大于父元素，在IE6、IE7会被隐藏而不是溢出\n\n解决方案：父级元素设置position:relative。\n\n### 4、图片默认有间距\n\n解决方案：使用float 为img 布局","tags":["前端基础题"]},{"title":"CSS中link和@import的区别","url":"/2021/03/13/CSS中link 和@import的区别/","content":"\n\n### 1、本质的差别：\n\nlink属于XHTML标签，而@import完全是css提供的一种方式。link标签除了可以加载css外，还可以做很多其他的事情，比如定义RSS，定义rel连接属性等，@import只能加载CSS。\n\n### 2、加载顺序的差别：\n\n当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再加载。所以有时候浏览@import加载CSS的页面时会没有样式（就是闪烁），网速慢的时候还挺明显。\n\n### 3、兼容性的差别：\n\n由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题，完全兼容。\n\n### 4、使用dom控制样式时的差别：\n\n当时用JavaScript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的（不支持）。\n\n### 5（不推荐）：\n\n@import可以在css中再次引入其他样式表，比如创建一个主样式表，在主样式表中再引入其他的样式表。\n\n\n\n[引用于这](https://zhuanlan.zhihu.com/p/242501240)\n\n","tags":["前端基础题"]},{"title":"每日总结4","url":"/2021/03/12/每日总结4/","content":"\n## 今天做了什么？\n\n##### 1、学习了微信小程序的配置文件、模板语法、事件绑定、样式WXSS、常见组件。\n\n##### 2、完善了开题PPT，晚上7:30~11:00都在听开题报告。\n\n## 用什么收获？\n\n##### 1、没有，继续学。\n\n## 明天计划？\n\n##### 1、把毕设的索引文献搞定。\n\n##### 2、继续学习小程序。\n\n##### 3、晚上PPT开题答辩。","tags":["生活"]},{"title":"每日总结3","url":"/2021/03/11/每日总结3/","content":"\n## 今天做了什么？\n\n##### 1、复习了Ajax运行原理及实现。\n\n##### 2、复习了了Vue前后端交互和Vue前端路由。\n\n##### 3、学习了Vue前端工程化。\n\n##### 4、了解了微信小程序，完成了环境准备。\n\n## 今天遇到的问题和收获？\n\n##### 1、没意识到，继续学。\n\n## 明天的大概计划？\n\n##### 1、把毕设的PPT重构。\n\n##### 2、开始学习微信小程序。\n\n\n\n","tags":["生活"]},{"title":"Promise的一道题","url":"/2021/03/11/Promise的一道题/","content":"\n## 题目:输出结果？\n\n```js\n        Promise.resolve().then(()=>{\n            console.log(0);\n            return Promise.resolve(4);\n        }).then((res)=>{\n            console.log(res);\n        })\n\n        Promise.resolve().then(()=>{\n            console.log(1);\n        }).then(()=>{\n            console.log(2);\n        }).then(()=>{\n            console.log(3);\n        }).then(()=>{\n            console.log(5);\n        }).then(()=>{\n            console.log(6);\n        })\n```\n\n## 答案：![image-20210311224451565](Promise的一道题/image-20210311224451565.png)\n\n![image-20210311224523228](Promise的一道题/image-20210311224523228.png)\n\n## 原因：![image-20210311224551681](Promise的一道题/image-20210311224551681.png)\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端基础题"]},{"title":"每日总结2","url":"/2021/03/10/每日总结2/","content":"\n## 今天做了什么？\n\n##### 1、复习了node.js的express框架\n\n##### 2、学习了Vue前后端交互和Vue前端路由\n\n##### 3、制定了每日的时间计划\n\n## 今天遇到的问题和收获？\n\n##### 1、没遇到印象深刻的问题，一些小的问题基本上当天解决了。\n\n##### 2、收获就是对Vue更加了解了。\n\n## 明天的大概计划？\n\n##### 1、复习今天刚学习的Vue的内容，一些相关的内容拿去和node.js及ajax对比。\n\n##### 2、估计明天复习不完，若是复习完了，把Vue剩下的内容学了。\n\n##### 3、计划15天把Vue剩下的内容学完，并学习一下数据库在前端方面的应用及其一些零碎的小东西。\n\n##### 4、若15天计划完成，则进行下一步，下载几个前端项目自己分析，同时复习之前所学的所有前端内容。\n\n##### 5、等到复习完所有前端内容并对前端有了整体的认知及其自己的理解后，做几个差不多的项目，同时整理所有的前端资源，统筹一下。\n\n##### 6、多加几个前端群，看看他们日常遇到的问题，并且每天拿出1个小时左右刷题。\n\n\n\n","tags":["生活"]},{"title":"每日总结1","url":"/2021/03/10/每日总结1/","content":"\n## 今天都做了什么？\n\n##### 1、从GitHub下载了一个基于Vue的简历模板，做了简单修改并上传到了新建的GitHub，通过GitHub pages实现了通过网址访问网站。\n\n## 问题和收获？\n\n##### 1、大概了解了基于git的GitHub[下载](https://blog.csdn.net/qq_37786775/article/details/80348946)和[上传](https://jingyan.baidu.com/article/295430f18d33490c7e0050e4.html)方法。\n\n##### 2、上传时可选用SSH地址和HTTPS地址，未知原因导致有时HTTPS地址上传出错。\n\n##### 3、布置pages时有source和theme chooser两个区域，未知原因上传库后：\n\n##### ①仅仅布置source区域。打开网站无反应。\n\n##### ②先布置source区域，后布置theme chooser区域。能成功打开上传的网站。\n\n##### ③先布置theme chooser区域，后布置source区域，打开网站会让你选择主题。\n\n##### 4、关于分支这方面不太了解。\n\n##### 5、因在上传过程中反复出错，在GitHub中新建了不少多余的库，需要删了。\n\n##### 6、大概了解了基于Vue项目的文件结构。\n\n## 接下来计划？\n\n##### 1、了解将OneNote笔记上传到博客方法（非必要，有空看）。\n\n##### 2、网上再找几个项目研究一下结构（基于Vue，Bootstrap，div+css，jQuery等）。\n\n##### 3、合理安排时间，每天找些前端题看。\n\n##### 4、各方面兼容性问题也要单独学习。\n\n##### 5、大体步骤：①研究项目结构。②修改内容查看变化。③模仿项目。④总结。","tags":["生活"]},{"title":"搭建hexo+github博客出现的问题","url":"/2021/03/08/搭建hexo+github博客出现的问题/","content":"\n\n\n<!-- # 搭建hexo+github博客出现的问题 -->\n\n\n\n## 1、搭建hexo+github博客步骤\n\n具体步骤参见[这里](https://zhuanlan.zhihu.com/p/26625249)\n\n按照这里搭建博客，能解决大部分问题。剩下一些细节性的问题需要自己解决。\n\n## 2、favicon.ico不显示问题\n\n解决方法：清理浏览器缓存。\n\n## 3、如何发布博客问题\n\n我的主题是aircloud，可以直接在blog\\source\\_posts文件夹里添加.md文件即可。例如：\n\n<!-- ![image-20210308162155775](搭建hexo+github博客出现的问题/image-20210308162155775.png) -->\n<img src=\"搭建hexo+github博客出现的问题/image-20210308162155775.png\" width=\"300px\" height=\"400px\">\n\n## 4、图片加载失败问题\n\n参见[这里](https://www.cnblogs.com/codecheng99/p/12380799.html)\n\n要注意的是，一定要在_posts文件夹中建立与.md文件**同名**的文件夹来存放图片。例如：\n\n<img src=\"搭建hexo+github博客出现的问题/image-20210308161203847.png\" width=\"300px\" height=\"400px\">\n<!-- ![image-20210308161203847](搭建hexo+github博客出现的问题/image-20210308161203847.png) -->\n\n","tags":["hexo"]},{"title":"hexo中图片无法加载问题","url":"/2021/03/08/hexo中图片无法加载问题/","content":"\n\n# 解决方法\n\n![image-20210308145109439](hexo中图片无法加载问题/image-20210308145109439.png)\n\n\n\n引用于[这里](https://www.cnblogs.com/codecheng99/p/12380799.html)\n\n\n\n","tags":["hexo"]},{"title":"Hello World","url":"/2021/03/06/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["hexo"],"categories":["Hexo"]}]